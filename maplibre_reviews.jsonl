{"repo": "maplibre/maplibre-gl-js", "pr_number": 6457, "comment_id": 2376735262, "commenter_login": "HarelM", "comment_body": "I dont think a chancelog is needed in this case, but thanks!", "file_path": "CHANGELOG.md", "diff_hunk": "@@ -6,6 +6,7 @@\n ### \ud83d\udc1e Bug fixes\n - Fix raster flickering when using terrain 3D and optimize terrain logic.\n - Fix issue where parent tiles are retained when deeper descendant tiles already cover the missing ideal tile. ([#6442](https://github.com/maplibre/maplibre-gl-js/pull/6442))\n+- Remove unnecessary `as any` casts. ([#6457](https://github.com/maplibre/maplibre-gl-js/pull/6457))", "created_at": "2025-09-24T18:42:35+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6445, "comment_id": 2365840108, "commenter_login": "CommanderStorm", "comment_body": "Nessesary to be `write` because we push to the wiki further down among others.", "file_path": ".github/workflows/release.yml", "diff_hunk": "@@ -35,6 +35,10 @@ jobs:\n     needs: release-check\n     if: ${{ needs.release-check.outputs.publish == 'true' }}\n     runs-on: ubuntu-latest\n+    permissions:\n+      contents: write", "created_at": "2025-09-20T21:37:01+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6445, "comment_id": 2365840219, "commenter_login": "CommanderStorm", "comment_body": "This will fail if we enable immutable releases for this repo.", "file_path": ".github/workflows/release.yml", "diff_hunk": "@@ -111,7 +119,7 @@ jobs:\n           bodyFile: ${{ steps.release_notes.outputs.release_notes }}\n           artifacts: \"dist.zip\"\n           artifactContentType: \"application/zip\"\n-          allowUpdates: true\n+          allowUpdates: false", "created_at": "2025-09-20T21:37:32+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6442, "comment_id": 2365334451, "commenter_login": "HarelM", "comment_body": "Do we really want to throw here? What about warnOnce or something?", "file_path": "src/source/source_cache.ts", "diff_hunk": "@@ -434,6 +440,23 @@ export class SourceCache extends Evented {\n         return loadedDescendents;\n     }\n \n+    /**\n+     * Determine if tile ids fully cover the current generation.\n+     * - 1st generation: need 4 children or 1 overscaled child\n+     * - 2nd generation: need 16 children or 1 overscaled child\n+     */\n+    _areDescendentsComplete(generationIDs: OverscaledTileID[], generationZ: number, ancestorZ: number) {\n+        if (generationZ <= ancestorZ) throw new Error('provided generation requires higher Z than ancestor');", "created_at": "2025-09-20T05:30:48+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6442, "comment_id": 2365335144, "commenter_login": "HarelM", "comment_body": "Is this test correct?", "file_path": "src/source/source_cache.test.ts", "diff_hunk": "@@ -971,6 +971,31 @@ describe('SourceCache._updateRetainedTiles', () => {\n         expect(Object.keys(retained).sort()).toEqual(expectedTiles.map(t => t.key).sort());\n     });\n \n+    test('_updateRetainedTiles incorrectly retains/requests parents when 2nd generation children are loaded', () => {", "created_at": "2025-09-20T05:33:46+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6442, "comment_id": 2365689645, "commenter_login": "wayofthefuture", "comment_body": "I wrote it as a failing test it should probably be titled something like \"...does not retain parents if 2nd generation children are loaded\"", "file_path": "src/source/source_cache.test.ts", "diff_hunk": "@@ -971,6 +971,31 @@ describe('SourceCache._updateRetainedTiles', () => {\n         expect(Object.keys(retained).sort()).toEqual(expectedTiles.map(t => t.key).sort());\n     });\n \n+    test('_updateRetainedTiles incorrectly retains/requests parents when 2nd generation children are loaded', () => {", "created_at": "2025-09-20T15:47:33+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6442, "comment_id": 2365691131, "commenter_login": "wayofthefuture", "comment_body": "It could warn and return false but the false would not necessarily mean anything (could cause weird bugs?). Something would be very wrong with the code if it were to be called in this manner. So I don't know...", "file_path": "src/source/source_cache.ts", "diff_hunk": "@@ -434,6 +440,23 @@ export class SourceCache extends Evented {\n         return loadedDescendents;\n     }\n \n+    /**\n+     * Determine if tile ids fully cover the current generation.\n+     * - 1st generation: need 4 children or 1 overscaled child\n+     * - 2nd generation: need 16 children or 1 overscaled child\n+     */\n+    _areDescendentsComplete(generationIDs: OverscaledTileID[], generationZ: number, ancestorZ: number) {\n+        if (generationZ <= ancestorZ) throw new Error('provided generation requires higher Z than ancestor');", "created_at": "2025-09-20T15:51:43+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6442, "comment_id": 2365744173, "commenter_login": "HarelM", "comment_body": "If this is a safe guard against something that we don't know how to reproduce or believe can truly happen I suggest to remove this code...", "file_path": "src/source/source_cache.ts", "diff_hunk": "@@ -434,6 +440,23 @@ export class SourceCache extends Evented {\n         return loadedDescendents;\n     }\n \n+    /**\n+     * Determine if tile ids fully cover the current generation.\n+     * - 1st generation: need 4 children or 1 overscaled child\n+     * - 2nd generation: need 16 children or 1 overscaled child\n+     */\n+    _areDescendentsComplete(generationIDs: OverscaledTileID[], generationZ: number, ancestorZ: number) {\n+        if (generationZ <= ancestorZ) throw new Error('provided generation requires higher Z than ancestor');", "created_at": "2025-09-20T18:04:43+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6442, "comment_id": 2365744274, "commenter_login": "HarelM", "comment_body": "Can you change the test name then, please?", "file_path": "src/source/source_cache.test.ts", "diff_hunk": "@@ -971,6 +971,31 @@ describe('SourceCache._updateRetainedTiles', () => {\n         expect(Object.keys(retained).sort()).toEqual(expectedTiles.map(t => t.key).sort());\n     });\n \n+    test('_updateRetainedTiles incorrectly retains/requests parents when 2nd generation children are loaded', () => {", "created_at": "2025-09-20T18:05:03+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6437, "comment_id": 2362571550, "commenter_login": "HarelM", "comment_body": "Didn't @louwers just removed those?", "file_path": ".github/workflows/codeql-analysis.yml", "diff_hunk": "@@ -39,6 +39,9 @@ jobs:\n     steps:\n     - name: Checkout repository\n       uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0\n+      with:\n+        fetch-depth: 0", "created_at": "2025-09-19T11:17:35+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6437, "comment_id": 2362735298, "commenter_login": "CommanderStorm", "comment_body": "Yes, sorry. That was a mistake", "file_path": ".github/workflows/codeql-analysis.yml", "diff_hunk": "@@ -39,6 +39,9 @@ jobs:\n     steps:\n     - name: Checkout repository\n       uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0\n+      with:\n+        fetch-depth: 0", "created_at": "2025-09-19T12:31:45+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356147855, "commenter_login": "HarelM", "comment_body": "This is probably a leftover...?", "file_path": "src/util/test/util.ts", "diff_hunk": "@@ -278,4 +279,17 @@ export function createTestCameraFrustum(fovy: number, aspectRatio: number, zNear\n     mat4.invert(invProj, proj);\n \n     return Frustum.fromInvProjectionMatrix(invProj, 1.0, 0.0);\n-};\n+}\n+\n+// export function logTiles(tileIDs: OverscaledTileID[]) {", "created_at": "2025-09-17T16:57:19+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356148951, "commenter_login": "HarelM", "comment_body": "This has a lint warning...", "file_path": "src/util/test/util.ts", "diff_hunk": "@@ -10,6 +10,7 @@ import {RequestManager} from '../request_manager';\n import {type IReadonlyTransform, type ITransform} from '../../geo/transform_interface';\n import {type Style} from '../../style/style';\n import {type Terrain} from '../../render/terrain';\n+import {type OverscaledTileID} from '../../source/tile_id';", "created_at": "2025-09-17T16:57:43+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356159397, "commenter_login": "HarelM", "comment_body": "Move the comments to the test description and split the tests if needed.", "file_path": "src/source/tile_id.test.ts", "diff_hunk": "@@ -98,12 +103,42 @@ describe('OverscaledTileID', () => {\n     });\n \n     test('.isChildOf', () => {\n+        // simple child of root tile", "created_at": "2025-09-17T17:00:02+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356164487, "commenter_login": "HarelM", "comment_body": "Consider moving this comment to be a different test.", "file_path": "src/source/tile_id.test.ts", "diff_hunk": "@@ -68,6 +68,11 @@ describe('OverscaledTileID', () => {\n             /*eslint no-new: 0*/\n             new OverscaledTileID(7, 0, 8, 0, 0);\n         }).toThrow();\n+        expect(() => {\n+            //tile with deeper canonicalZ than overscaledZ", "created_at": "2025-09-17T17:01:06+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356165234, "commenter_login": "HarelM", "comment_body": "These tests are great! Good job of adding those!", "file_path": "src/source/tile_id.test.ts", "diff_hunk": "@@ -98,12 +103,42 @@ describe('OverscaledTileID', () => {\n     });\n \n     test('.isChildOf', () => {\n+        // simple child of root tile\n         expect(\n             new OverscaledTileID(2, 0, 2, 0, 0).isChildOf(new OverscaledTileID(0, 0, 0, 0, 0))\n         ).toBeTruthy();\n+        // not a child at a different wrap\n         expect(\n             new OverscaledTileID(2, 0, 2, 0, 0).isChildOf(new OverscaledTileID(0, 1, 0, 0, 0))\n         ).toBeFalsy();\n     });\n \n+    test('.isChildOf - root tile should not be child of itself', () => {\n+        const root = new OverscaledTileID(0, 0, 0, 0, 0);\n+        expect(root.isChildOf(root)).toBe(false);\n+    });\n+\n+    test('.isChildOf - child with different coordinates is not child of parent', () => {\n+        const parent = new OverscaledTileID(1, 0, 1, 0, 0);\n+        const child  = new OverscaledTileID(2, 0, 2, 2, 0);\n+        expect(child.isChildOf(parent)).toBe(false);\n+    });\n+\n+    test('.isChildOf - descendant is child of ancestor', () => {\n+        const parent = new OverscaledTileID(1, 0, 1, 0, 0);\n+        const child  = new OverscaledTileID(4, 0, 4, 3, 5);\n+        expect(child.isChildOf(parent)).toBe(true);\n+    });\n+\n+    test('.isChildOf - descendant with different coordinates is not child of ancestor', () => {", "created_at": "2025-09-17T17:01:25+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356168161, "commenter_login": "HarelM", "comment_body": "Looks like the method parameters have changed, does the comment above it still relevant?\nI would consider moving the comment to be a tsdoc comment of the method instead of adding a comment above its usage...", "file_path": "src/source/source_cache.ts", "diff_hunk": "@@ -729,7 +750,7 @@ export class SourceCache extends Evented {\n         }\n \n         // retain any loaded children of ideal tiles up to maxCoveringZoom\n-        this._retainLoadedChildren(missingTiles, zoom, maxCoveringZoom, retain);\n+        this._retainLoadedChildren(missingTiles, retain);", "created_at": "2025-09-17T17:02:45+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356177859, "commenter_login": "HarelM", "comment_body": "I don't think there's a need to mention the old approach here, it would make sense to talk about it in the PR, but this comment should only reflect what the method is currently doing.\nBTW, this is a great summary of the problem and the implementation!", "file_path": "src/source/source_cache.ts", "diff_hunk": "@@ -358,50 +358,75 @@ export class SourceCache extends Evented {\n     }\n \n     /**\n-     * For a given set of tiles, retain children that are loaded and have a zoom\n-     * between `zoom` (exclusive) and `maxCoveringZoom` (inclusive)\n+     * Retain the uppermost loaded children of each provided target tile, within a variable covering zoom range.\n+     *\n+     * On pitched maps, different parts of the screen show different zoom levels simultaneously.\n+     * Ideal tiles are generated using coveringTiles() above, which returns the ideal tile set for\n+     * the current pitched plane, which can carry tiles of varying zooms (overscaledZ).\n+     * See: https://maplibre.org/maplibre-gl-js/docs/examples/level-of-detail-control/\n+     *\n+     * A fixed `maxCoveringZoom` on a pitched map would incorrectly intersect with some\n+     * ideal tiles and cause distant high-pitch tiles to skip their uppermost children.\n+     *\n+     * To solve this, we calculate the max covering zoom for each ideal tile separately using its\n+     * `overscaledZ`. This effectively makes the \"max covering zoom plane\" parallel to the\n+     * \"ideal tile plane,\" ensuring that we correctly capture the uppermost children\n+     * of each ideal tile across the pitched view.\n+     *\n+     * Analogy: imagine two sheets of paper in 3D space:\n+     *   - one sheet = ideal tiles at varying overscaledZ\n+     *   - the second sheet = maxCoveringZoom\n+     * With the old approach, the sheets intersected. With the below method, they remain parallel.", "created_at": "2025-09-17T17:07:03+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356190842, "commenter_login": "HarelM", "comment_body": "This method is well written with good comments, but I would like to see less comments and maybe more small methods with the relevant comment as a method name? Or maybe names that are descriptive enough to avoid some of the comments here, as comments test to get stale over time.", "file_path": "src/source/source_cache.ts", "diff_hunk": "@@ -358,50 +358,75 @@ export class SourceCache extends Evented {\n     }\n \n     /**\n-     * For a given set of tiles, retain children that are loaded and have a zoom\n-     * between `zoom` (exclusive) and `maxCoveringZoom` (inclusive)\n+     * Retain the uppermost loaded children of each provided target tile, within a variable covering zoom range.\n+     *\n+     * On pitched maps, different parts of the screen show different zoom levels simultaneously.\n+     * Ideal tiles are generated using coveringTiles() above, which returns the ideal tile set for\n+     * the current pitched plane, which can carry tiles of varying zooms (overscaledZ).\n+     * See: https://maplibre.org/maplibre-gl-js/docs/examples/level-of-detail-control/\n+     *\n+     * A fixed `maxCoveringZoom` on a pitched map would incorrectly intersect with some\n+     * ideal tiles and cause distant high-pitch tiles to skip their uppermost children.\n+     *\n+     * To solve this, we calculate the max covering zoom for each ideal tile separately using its\n+     * `overscaledZ`. This effectively makes the \"max covering zoom plane\" parallel to the\n+     * \"ideal tile plane,\" ensuring that we correctly capture the uppermost children\n+     * of each ideal tile across the pitched view.\n+     *\n+     * Analogy: imagine two sheets of paper in 3D space:\n+     *   - one sheet = ideal tiles at varying overscaledZ\n+     *   - the second sheet = maxCoveringZoom\n+     * With the old approach, the sheets intersected. With the below method, they remain parallel.\n      */\n+\n     _retainLoadedChildren(\n-        idealTiles: {\n-            [_ in any]: OverscaledTileID;\n-        },\n-        zoom: number,\n-        maxCoveringZoom: number,\n-        retain: {\n-            [_ in any]: OverscaledTileID;\n-        }\n+        targetTiles: { [_: string]: OverscaledTileID },\n+        retain: { [_: string]: OverscaledTileID }\n     ) {\n-        for (const id in this._tiles) {\n-            let tile = this._tiles[id];\n-\n-            // only consider renderable tiles up to maxCoveringZoom\n-            if (retain[id] ||\n-                !tile.hasData() ||\n-                tile.tileID.overscaledZ <= zoom ||\n-                tile.tileID.overscaledZ > maxCoveringZoom\n-            ) continue;\n-\n-            // loop through parents and retain the topmost loaded one if found\n-            let topmostLoadedID = tile.tileID;\n-            while (tile && tile.tileID.overscaledZ > zoom + 1) {\n-                const parentID = tile.tileID.scaledTo(tile.tileID.overscaledZ - 1);\n-\n-                tile = this._tiles[parentID.key];\n-\n-                if (tile && tile.hasData()) {\n-                    topmostLoadedID = parentID;\n+        //convert target tiles dictionary to array for code readability and quicker performance below\n+        const targetTileIDs = Object.values(targetTiles);\n+\n+        // create dictionary for the qualified loaded descendents of each target tile\n+        const loadedDescendents: { [_: string]: Tile[] } = {};\n+\n+        // enumerate tiles currently in this source and find the loaded descendents of each target tile", "created_at": "2025-09-17T17:11:46+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356198770, "commenter_login": "HarelM", "comment_body": "You can create an array and run the same test several times, this will allow the test harness to report the right failure in case one of these tests faile, i.e.\n\n```ts\nfor (let pitch of [0, 20, 40, ...]) {\n     test('retains loaded children for pitch: ' + pitch, () => {\n       ...\n```", "file_path": "src/source/source_cache.test.ts", "diff_hunk": "@@ -938,31 +939,128 @@ describe('SourceCache._updateRetainedTiles', () => {\n         sourceCache._tiles[idealTile.key] = new Tile(idealTile, undefined);\n         sourceCache._tiles[idealTile.key].state = 'errored';\n \n-        const loadedChildren = [\n-            new OverscaledTileID(4, 0, 4, 2, 4),\n-            new OverscaledTileID(4, 0, 4, 3, 4),\n-            new OverscaledTileID(4, 0, 4, 2, 5),\n+        const loadedTiles = [\n+            // loaded children - topmost zoom partially covered\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            // loaded children - 2nd topmost zoom fully covered\n             new OverscaledTileID(5, 0, 5, 6, 10),\n             new OverscaledTileID(5, 0, 5, 7, 10),\n             new OverscaledTileID(5, 0, 5, 6, 11),\n-            new OverscaledTileID(5, 0, 5, 7, 11)\n+            new OverscaledTileID(5, 0, 5, 7, 11),\n+            // loaded parents - to be requested because ideal tile is not completely covered by children (z=4)\n+            new OverscaledTileID(0, 0, 0, 0, 0),\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n+            new OverscaledTileID(1, 0, 1, 0, 0)\n         ];\n-\n-        for (const t of loadedChildren) {\n+        for (const t of loadedTiles) {\n             sourceCache._tiles[t.key] = new Tile(t, undefined);\n             sourceCache._tiles[t.key].state = 'loaded';\n         }\n \n-        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n-        expect(Object.keys(retained).sort()).toEqual([\n-            // parents are requested because ideal ideal tile is not completely covered by\n-            // loaded child tiles\n-            new OverscaledTileID(0, 0, 0, 0, 0),\n-            new OverscaledTileID(2, 0, 2, 0, 1),\n-            new OverscaledTileID(1, 0, 1, 0, 0),\n+        const expectedTiles = [\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n             idealTile\n-        ].concat(loadedChildren).map(t => t.key).sort());\n+        ];\n+\n+        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n+        expect(Object.keys(retained).sort()).toEqual(expectedTiles.map(t => t.key).sort());\n+    });\n+\n+    test('retains loaded children for pitched maps', async () => {\n+        testPitch(0);", "created_at": "2025-09-17T17:15:27+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356201575, "commenter_login": "HarelM", "comment_body": "I'm not sure this comment is useful, it's part of the parameters of the method, you can use the tsdoc to write this down I believe.", "file_path": "src/source/source_cache.test.ts", "diff_hunk": "@@ -938,31 +939,128 @@ describe('SourceCache._updateRetainedTiles', () => {\n         sourceCache._tiles[idealTile.key] = new Tile(idealTile, undefined);\n         sourceCache._tiles[idealTile.key].state = 'errored';\n \n-        const loadedChildren = [\n-            new OverscaledTileID(4, 0, 4, 2, 4),\n-            new OverscaledTileID(4, 0, 4, 3, 4),\n-            new OverscaledTileID(4, 0, 4, 2, 5),\n+        const loadedTiles = [\n+            // loaded children - topmost zoom partially covered\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            // loaded children - 2nd topmost zoom fully covered\n             new OverscaledTileID(5, 0, 5, 6, 10),\n             new OverscaledTileID(5, 0, 5, 7, 10),\n             new OverscaledTileID(5, 0, 5, 6, 11),\n-            new OverscaledTileID(5, 0, 5, 7, 11)\n+            new OverscaledTileID(5, 0, 5, 7, 11),\n+            // loaded parents - to be requested because ideal tile is not completely covered by children (z=4)\n+            new OverscaledTileID(0, 0, 0, 0, 0),\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n+            new OverscaledTileID(1, 0, 1, 0, 0)\n         ];\n-\n-        for (const t of loadedChildren) {\n+        for (const t of loadedTiles) {\n             sourceCache._tiles[t.key] = new Tile(t, undefined);\n             sourceCache._tiles[t.key].state = 'loaded';\n         }\n \n-        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n-        expect(Object.keys(retained).sort()).toEqual([\n-            // parents are requested because ideal ideal tile is not completely covered by\n-            // loaded child tiles\n-            new OverscaledTileID(0, 0, 0, 0, 0),\n-            new OverscaledTileID(2, 0, 2, 0, 1),\n-            new OverscaledTileID(1, 0, 1, 0, 0),\n+        const expectedTiles = [\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n             idealTile\n-        ].concat(loadedChildren).map(t => t.key).sort());\n+        ];\n+\n+        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n+        expect(Object.keys(retained).sort()).toEqual(expectedTiles.map(t => t.key).sort());\n+    });\n+\n+    test('retains loaded children for pitched maps', async () => {\n+        testPitch(0);\n+        testPitch(20);\n+        testPitch(40);\n+        testPitch(65);\n+        testPitch(75);\n+        testPitch(85);\n+\n+        function testPitch(pitch: number) {\n+            const transform = new MercatorTransform();\n+            transform.resize(512, 512);\n+            transform.setZoom(10);\n+            transform.setMaxPitch(90);\n+            transform.setPitch(pitch);\n+\n+            const sourceCache = createSourceCache();\n+            sourceCache._source.loadTile = async (tile) => {\n+                tile.state = 'errored';  //all ideal tiles generated from coveringTiles should be unavailable\n+            };\n+\n+            //see covering tile logic in source_cache.update\n+            const idealTileIDs = coveringTiles(transform, {\n+                tileSize: sourceCache.usedForTerrain ? sourceCache.tileSize : sourceCache._source.tileSize,\n+                minzoom: sourceCache._source.minzoom,\n+                maxzoom: sourceCache._source.maxzoom,\n+                roundZoom: sourceCache._source.roundZoom,\n+                reparseOverscaled: sourceCache._source.reparseOverscaled,\n+                calculateTileZoom: sourceCache._source.calculateTileZoom\n+            });\n+\n+            const idealChildIDs = idealTileIDs.flatMap(id => id.children(sourceCache._source.maxzoom));\n+            for (const idealID of idealChildIDs) {\n+                const tile = new Tile(idealID, undefined);\n+                tile.state = 'loaded';  //all children are loaded to be retained for missing ideal tiles\n+                sourceCache._tiles[idealID.key] = tile;\n+            }\n+\n+            // create retainment dictionary to pass by reference to _retainLoadedChildren for modification\n+            const retain: {[key: string]: OverscaledTileID} = {};\n+\n+            // create missing dictionary for ideal tiles for passing into _retainLoadedChildren\n+            const missingTiles: {[key: string]: OverscaledTileID} = {};\n+\n+            // mark all ideal tiles as retained and also as missing with no data for child retainment\n+            idealTileIDs.forEach(idealID => {\n+                retain[idealID.key] = idealID;\n+                missingTiles[idealID.key] = idealID;\n+            });\n+\n+            // retain loaded children for the missing ideal tiles\n+            sourceCache._retainLoadedChildren(missingTiles, retain);\n+\n+            expect(Object.keys(retain).sort()).toEqual(\n+                idealChildIDs.concat(idealTileIDs).map(id => id.key).sort()\n+            );\n+        }\n+    });\n+\n+    test('retains only uppermost zoom children when multiple zoom levels are loaded', () => {\n+        const sourceCache = createSourceCache();\n+        sourceCache._source.loadTile = async (tile) => {\n+            tile.state = 'errored';\n+        };\n+\n+        const idealTileID = new OverscaledTileID(2, 0, 2, 1, 1);\n+        const idealTiles: {[key: string]: OverscaledTileID} = {[idealTileID.key]: idealTileID};\n+\n+        // add children at z=3, z=4, and z=5\n+        const children = [\n+            new OverscaledTileID(3, 0, 3, 2, 2),  //keep\n+            new OverscaledTileID(3, 0, 3, 3, 2),  //keep\n+            new OverscaledTileID(4, 0, 4, 4, 4),  //discard\n+            new OverscaledTileID(5, 0, 5, 8, 8),  //discard\n+        ];\n+        for (const child of children) {\n+            const tile = new Tile(child, undefined);\n+            tile.state = 'loaded';\n+            sourceCache._tiles[child.key] = tile;\n+        }\n+\n+        // create retainment dictionary to pass by reference to _retainLoadedChildren for modification", "created_at": "2025-09-17T17:16:46+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356203263, "commenter_login": "HarelM", "comment_body": "nit picking: can we use regular `for (const a of b)`?", "file_path": "src/source/source_cache.test.ts", "diff_hunk": "@@ -938,31 +939,128 @@ describe('SourceCache._updateRetainedTiles', () => {\n         sourceCache._tiles[idealTile.key] = new Tile(idealTile, undefined);\n         sourceCache._tiles[idealTile.key].state = 'errored';\n \n-        const loadedChildren = [\n-            new OverscaledTileID(4, 0, 4, 2, 4),\n-            new OverscaledTileID(4, 0, 4, 3, 4),\n-            new OverscaledTileID(4, 0, 4, 2, 5),\n+        const loadedTiles = [\n+            // loaded children - topmost zoom partially covered\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            // loaded children - 2nd topmost zoom fully covered\n             new OverscaledTileID(5, 0, 5, 6, 10),\n             new OverscaledTileID(5, 0, 5, 7, 10),\n             new OverscaledTileID(5, 0, 5, 6, 11),\n-            new OverscaledTileID(5, 0, 5, 7, 11)\n+            new OverscaledTileID(5, 0, 5, 7, 11),\n+            // loaded parents - to be requested because ideal tile is not completely covered by children (z=4)\n+            new OverscaledTileID(0, 0, 0, 0, 0),\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n+            new OverscaledTileID(1, 0, 1, 0, 0)\n         ];\n-\n-        for (const t of loadedChildren) {\n+        for (const t of loadedTiles) {\n             sourceCache._tiles[t.key] = new Tile(t, undefined);\n             sourceCache._tiles[t.key].state = 'loaded';\n         }\n \n-        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n-        expect(Object.keys(retained).sort()).toEqual([\n-            // parents are requested because ideal ideal tile is not completely covered by\n-            // loaded child tiles\n-            new OverscaledTileID(0, 0, 0, 0, 0),\n-            new OverscaledTileID(2, 0, 2, 0, 1),\n-            new OverscaledTileID(1, 0, 1, 0, 0),\n+        const expectedTiles = [\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n             idealTile\n-        ].concat(loadedChildren).map(t => t.key).sort());\n+        ];\n+\n+        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n+        expect(Object.keys(retained).sort()).toEqual(expectedTiles.map(t => t.key).sort());\n+    });\n+\n+    test('retains loaded children for pitched maps', async () => {\n+        testPitch(0);\n+        testPitch(20);\n+        testPitch(40);\n+        testPitch(65);\n+        testPitch(75);\n+        testPitch(85);\n+\n+        function testPitch(pitch: number) {\n+            const transform = new MercatorTransform();\n+            transform.resize(512, 512);\n+            transform.setZoom(10);\n+            transform.setMaxPitch(90);\n+            transform.setPitch(pitch);\n+\n+            const sourceCache = createSourceCache();\n+            sourceCache._source.loadTile = async (tile) => {\n+                tile.state = 'errored';  //all ideal tiles generated from coveringTiles should be unavailable\n+            };\n+\n+            //see covering tile logic in source_cache.update\n+            const idealTileIDs = coveringTiles(transform, {\n+                tileSize: sourceCache.usedForTerrain ? sourceCache.tileSize : sourceCache._source.tileSize,\n+                minzoom: sourceCache._source.minzoom,\n+                maxzoom: sourceCache._source.maxzoom,\n+                roundZoom: sourceCache._source.roundZoom,\n+                reparseOverscaled: sourceCache._source.reparseOverscaled,\n+                calculateTileZoom: sourceCache._source.calculateTileZoom\n+            });\n+\n+            const idealChildIDs = idealTileIDs.flatMap(id => id.children(sourceCache._source.maxzoom));\n+            for (const idealID of idealChildIDs) {\n+                const tile = new Tile(idealID, undefined);\n+                tile.state = 'loaded';  //all children are loaded to be retained for missing ideal tiles\n+                sourceCache._tiles[idealID.key] = tile;\n+            }\n+\n+            // create retainment dictionary to pass by reference to _retainLoadedChildren for modification\n+            const retain: {[key: string]: OverscaledTileID} = {};\n+\n+            // create missing dictionary for ideal tiles for passing into _retainLoadedChildren\n+            const missingTiles: {[key: string]: OverscaledTileID} = {};\n+\n+            // mark all ideal tiles as retained and also as missing with no data for child retainment\n+            idealTileIDs.forEach(idealID => {", "created_at": "2025-09-17T17:17:35+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356204707, "commenter_login": "HarelM", "comment_body": "This there a collocation assert that can be used instead of sorting etc every time? If not, this is good enough...", "file_path": "src/source/source_cache.test.ts", "diff_hunk": "@@ -938,31 +939,128 @@ describe('SourceCache._updateRetainedTiles', () => {\n         sourceCache._tiles[idealTile.key] = new Tile(idealTile, undefined);\n         sourceCache._tiles[idealTile.key].state = 'errored';\n \n-        const loadedChildren = [\n-            new OverscaledTileID(4, 0, 4, 2, 4),\n-            new OverscaledTileID(4, 0, 4, 3, 4),\n-            new OverscaledTileID(4, 0, 4, 2, 5),\n+        const loadedTiles = [\n+            // loaded children - topmost zoom partially covered\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            // loaded children - 2nd topmost zoom fully covered\n             new OverscaledTileID(5, 0, 5, 6, 10),\n             new OverscaledTileID(5, 0, 5, 7, 10),\n             new OverscaledTileID(5, 0, 5, 6, 11),\n-            new OverscaledTileID(5, 0, 5, 7, 11)\n+            new OverscaledTileID(5, 0, 5, 7, 11),\n+            // loaded parents - to be requested because ideal tile is not completely covered by children (z=4)\n+            new OverscaledTileID(0, 0, 0, 0, 0),\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n+            new OverscaledTileID(1, 0, 1, 0, 0)\n         ];\n-\n-        for (const t of loadedChildren) {\n+        for (const t of loadedTiles) {\n             sourceCache._tiles[t.key] = new Tile(t, undefined);\n             sourceCache._tiles[t.key].state = 'loaded';\n         }\n \n-        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n-        expect(Object.keys(retained).sort()).toEqual([\n-            // parents are requested because ideal ideal tile is not completely covered by\n-            // loaded child tiles\n-            new OverscaledTileID(0, 0, 0, 0, 0),\n-            new OverscaledTileID(2, 0, 2, 0, 1),\n-            new OverscaledTileID(1, 0, 1, 0, 0),\n+        const expectedTiles = [\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n             idealTile\n-        ].concat(loadedChildren).map(t => t.key).sort());\n+        ];\n+\n+        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n+        expect(Object.keys(retained).sort()).toEqual(expectedTiles.map(t => t.key).sort());\n+    });\n+\n+    test('retains loaded children for pitched maps', async () => {\n+        testPitch(0);\n+        testPitch(20);\n+        testPitch(40);\n+        testPitch(65);\n+        testPitch(75);\n+        testPitch(85);\n+\n+        function testPitch(pitch: number) {\n+            const transform = new MercatorTransform();\n+            transform.resize(512, 512);\n+            transform.setZoom(10);\n+            transform.setMaxPitch(90);\n+            transform.setPitch(pitch);\n+\n+            const sourceCache = createSourceCache();\n+            sourceCache._source.loadTile = async (tile) => {\n+                tile.state = 'errored';  //all ideal tiles generated from coveringTiles should be unavailable\n+            };\n+\n+            //see covering tile logic in source_cache.update\n+            const idealTileIDs = coveringTiles(transform, {\n+                tileSize: sourceCache.usedForTerrain ? sourceCache.tileSize : sourceCache._source.tileSize,\n+                minzoom: sourceCache._source.minzoom,\n+                maxzoom: sourceCache._source.maxzoom,\n+                roundZoom: sourceCache._source.roundZoom,\n+                reparseOverscaled: sourceCache._source.reparseOverscaled,\n+                calculateTileZoom: sourceCache._source.calculateTileZoom\n+            });\n+\n+            const idealChildIDs = idealTileIDs.flatMap(id => id.children(sourceCache._source.maxzoom));\n+            for (const idealID of idealChildIDs) {\n+                const tile = new Tile(idealID, undefined);\n+                tile.state = 'loaded';  //all children are loaded to be retained for missing ideal tiles\n+                sourceCache._tiles[idealID.key] = tile;\n+            }\n+\n+            // create retainment dictionary to pass by reference to _retainLoadedChildren for modification\n+            const retain: {[key: string]: OverscaledTileID} = {};\n+\n+            // create missing dictionary for ideal tiles for passing into _retainLoadedChildren\n+            const missingTiles: {[key: string]: OverscaledTileID} = {};\n+\n+            // mark all ideal tiles as retained and also as missing with no data for child retainment\n+            idealTileIDs.forEach(idealID => {\n+                retain[idealID.key] = idealID;\n+                missingTiles[idealID.key] = idealID;\n+            });\n+\n+            // retain loaded children for the missing ideal tiles\n+            sourceCache._retainLoadedChildren(missingTiles, retain);\n+\n+            expect(Object.keys(retain).sort()).toEqual(", "created_at": "2025-09-17T17:18:14+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356206371, "commenter_login": "HarelM", "comment_body": "This method is redundant as the zoom can be seen in the below list.", "file_path": "src/source/source_cache.test.ts", "diff_hunk": "@@ -938,31 +939,128 @@ describe('SourceCache._updateRetainedTiles', () => {\n         sourceCache._tiles[idealTile.key] = new Tile(idealTile, undefined);\n         sourceCache._tiles[idealTile.key].state = 'errored';\n \n-        const loadedChildren = [\n-            new OverscaledTileID(4, 0, 4, 2, 4),\n-            new OverscaledTileID(4, 0, 4, 3, 4),\n-            new OverscaledTileID(4, 0, 4, 2, 5),\n+        const loadedTiles = [\n+            // loaded children - topmost zoom partially covered\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            // loaded children - 2nd topmost zoom fully covered\n             new OverscaledTileID(5, 0, 5, 6, 10),\n             new OverscaledTileID(5, 0, 5, 7, 10),\n             new OverscaledTileID(5, 0, 5, 6, 11),\n-            new OverscaledTileID(5, 0, 5, 7, 11)\n+            new OverscaledTileID(5, 0, 5, 7, 11),\n+            // loaded parents - to be requested because ideal tile is not completely covered by children (z=4)\n+            new OverscaledTileID(0, 0, 0, 0, 0),\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n+            new OverscaledTileID(1, 0, 1, 0, 0)\n         ];\n-\n-        for (const t of loadedChildren) {\n+        for (const t of loadedTiles) {\n             sourceCache._tiles[t.key] = new Tile(t, undefined);\n             sourceCache._tiles[t.key].state = 'loaded';\n         }\n \n-        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n-        expect(Object.keys(retained).sort()).toEqual([\n-            // parents are requested because ideal ideal tile is not completely covered by\n-            // loaded child tiles\n-            new OverscaledTileID(0, 0, 0, 0, 0),\n-            new OverscaledTileID(2, 0, 2, 0, 1),\n-            new OverscaledTileID(1, 0, 1, 0, 0),\n+        const expectedTiles = [\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n             idealTile\n-        ].concat(loadedChildren).map(t => t.key).sort());\n+        ];\n+\n+        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n+        expect(Object.keys(retained).sort()).toEqual(expectedTiles.map(t => t.key).sort());\n+    });\n+\n+    test('retains loaded children for pitched maps', async () => {\n+        testPitch(0);\n+        testPitch(20);\n+        testPitch(40);\n+        testPitch(65);\n+        testPitch(75);\n+        testPitch(85);\n+\n+        function testPitch(pitch: number) {\n+            const transform = new MercatorTransform();\n+            transform.resize(512, 512);\n+            transform.setZoom(10);\n+            transform.setMaxPitch(90);\n+            transform.setPitch(pitch);\n+\n+            const sourceCache = createSourceCache();\n+            sourceCache._source.loadTile = async (tile) => {\n+                tile.state = 'errored';  //all ideal tiles generated from coveringTiles should be unavailable\n+            };\n+\n+            //see covering tile logic in source_cache.update\n+            const idealTileIDs = coveringTiles(transform, {\n+                tileSize: sourceCache.usedForTerrain ? sourceCache.tileSize : sourceCache._source.tileSize,\n+                minzoom: sourceCache._source.minzoom,\n+                maxzoom: sourceCache._source.maxzoom,\n+                roundZoom: sourceCache._source.roundZoom,\n+                reparseOverscaled: sourceCache._source.reparseOverscaled,\n+                calculateTileZoom: sourceCache._source.calculateTileZoom\n+            });\n+\n+            const idealChildIDs = idealTileIDs.flatMap(id => id.children(sourceCache._source.maxzoom));\n+            for (const idealID of idealChildIDs) {\n+                const tile = new Tile(idealID, undefined);\n+                tile.state = 'loaded';  //all children are loaded to be retained for missing ideal tiles\n+                sourceCache._tiles[idealID.key] = tile;\n+            }\n+\n+            // create retainment dictionary to pass by reference to _retainLoadedChildren for modification\n+            const retain: {[key: string]: OverscaledTileID} = {};\n+\n+            // create missing dictionary for ideal tiles for passing into _retainLoadedChildren\n+            const missingTiles: {[key: string]: OverscaledTileID} = {};\n+\n+            // mark all ideal tiles as retained and also as missing with no data for child retainment\n+            idealTileIDs.forEach(idealID => {\n+                retain[idealID.key] = idealID;\n+                missingTiles[idealID.key] = idealID;\n+            });\n+\n+            // retain loaded children for the missing ideal tiles\n+            sourceCache._retainLoadedChildren(missingTiles, retain);\n+\n+            expect(Object.keys(retain).sort()).toEqual(\n+                idealChildIDs.concat(idealTileIDs).map(id => id.key).sort()\n+            );\n+        }\n+    });\n+\n+    test('retains only uppermost zoom children when multiple zoom levels are loaded', () => {\n+        const sourceCache = createSourceCache();\n+        sourceCache._source.loadTile = async (tile) => {\n+            tile.state = 'errored';\n+        };\n+\n+        const idealTileID = new OverscaledTileID(2, 0, 2, 1, 1);\n+        const idealTiles: {[key: string]: OverscaledTileID} = {[idealTileID.key]: idealTileID};\n+\n+        // add children at z=3, z=4, and z=5", "created_at": "2025-09-17T17:18:52+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356260431, "commenter_login": "wayofthefuture", "comment_body": "I wrote it as it was very helpful for creating tests. The linter complained about it being unused. Guess I will remove...", "file_path": "src/util/test/util.ts", "diff_hunk": "@@ -278,4 +279,17 @@ export function createTestCameraFrustum(fovy: number, aspectRatio: number, zNear\n     mat4.invert(invProj, proj);\n \n     return Frustum.fromInvProjectionMatrix(invProj, 1.0, 0.0);\n-};\n+}\n+\n+// export function logTiles(tileIDs: OverscaledTileID[]) {", "created_at": "2025-09-17T17:40:30+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356262722, "commenter_login": "wayofthefuture", "comment_body": "Lol and proving your point that comments become stale over time \ud83d\ude04 ", "file_path": "src/source/source_cache.ts", "diff_hunk": "@@ -729,7 +750,7 @@ export class SourceCache extends Evented {\n         }\n \n         // retain any loaded children of ideal tiles up to maxCoveringZoom\n-        this._retainLoadedChildren(missingTiles, zoom, maxCoveringZoom, retain);\n+        this._retainLoadedChildren(missingTiles, retain);", "created_at": "2025-09-17T17:41:34+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6399, "comment_id": 2356609641, "commenter_login": "wayofthefuture", "comment_body": "All the other tests were using so I don't think so...", "file_path": "src/source/source_cache.test.ts", "diff_hunk": "@@ -938,31 +939,128 @@ describe('SourceCache._updateRetainedTiles', () => {\n         sourceCache._tiles[idealTile.key] = new Tile(idealTile, undefined);\n         sourceCache._tiles[idealTile.key].state = 'errored';\n \n-        const loadedChildren = [\n-            new OverscaledTileID(4, 0, 4, 2, 4),\n-            new OverscaledTileID(4, 0, 4, 3, 4),\n-            new OverscaledTileID(4, 0, 4, 2, 5),\n+        const loadedTiles = [\n+            // loaded children - topmost zoom partially covered\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            // loaded children - 2nd topmost zoom fully covered\n             new OverscaledTileID(5, 0, 5, 6, 10),\n             new OverscaledTileID(5, 0, 5, 7, 10),\n             new OverscaledTileID(5, 0, 5, 6, 11),\n-            new OverscaledTileID(5, 0, 5, 7, 11)\n+            new OverscaledTileID(5, 0, 5, 7, 11),\n+            // loaded parents - to be requested because ideal tile is not completely covered by children (z=4)\n+            new OverscaledTileID(0, 0, 0, 0, 0),\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n+            new OverscaledTileID(1, 0, 1, 0, 0)\n         ];\n-\n-        for (const t of loadedChildren) {\n+        for (const t of loadedTiles) {\n             sourceCache._tiles[t.key] = new Tile(t, undefined);\n             sourceCache._tiles[t.key].state = 'loaded';\n         }\n \n-        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n-        expect(Object.keys(retained).sort()).toEqual([\n-            // parents are requested because ideal ideal tile is not completely covered by\n-            // loaded child tiles\n-            new OverscaledTileID(0, 0, 0, 0, 0),\n-            new OverscaledTileID(2, 0, 2, 0, 1),\n-            new OverscaledTileID(1, 0, 1, 0, 0),\n+        const expectedTiles = [\n+            new OverscaledTileID(4, 0, 4, 2, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 3, 4),  //topmost child\n+            new OverscaledTileID(4, 0, 4, 2, 5),  //topmost child\n+            new OverscaledTileID(2, 0, 2, 0, 1),  //parent\n             idealTile\n-        ].concat(loadedChildren).map(t => t.key).sort());\n+        ];\n+\n+        const retained = sourceCache._updateRetainedTiles([idealTile], 3);\n+        expect(Object.keys(retained).sort()).toEqual(expectedTiles.map(t => t.key).sort());\n+    });\n+\n+    test('retains loaded children for pitched maps', async () => {\n+        testPitch(0);\n+        testPitch(20);\n+        testPitch(40);\n+        testPitch(65);\n+        testPitch(75);\n+        testPitch(85);\n+\n+        function testPitch(pitch: number) {\n+            const transform = new MercatorTransform();\n+            transform.resize(512, 512);\n+            transform.setZoom(10);\n+            transform.setMaxPitch(90);\n+            transform.setPitch(pitch);\n+\n+            const sourceCache = createSourceCache();\n+            sourceCache._source.loadTile = async (tile) => {\n+                tile.state = 'errored';  //all ideal tiles generated from coveringTiles should be unavailable\n+            };\n+\n+            //see covering tile logic in source_cache.update\n+            const idealTileIDs = coveringTiles(transform, {\n+                tileSize: sourceCache.usedForTerrain ? sourceCache.tileSize : sourceCache._source.tileSize,\n+                minzoom: sourceCache._source.minzoom,\n+                maxzoom: sourceCache._source.maxzoom,\n+                roundZoom: sourceCache._source.roundZoom,\n+                reparseOverscaled: sourceCache._source.reparseOverscaled,\n+                calculateTileZoom: sourceCache._source.calculateTileZoom\n+            });\n+\n+            const idealChildIDs = idealTileIDs.flatMap(id => id.children(sourceCache._source.maxzoom));\n+            for (const idealID of idealChildIDs) {\n+                const tile = new Tile(idealID, undefined);\n+                tile.state = 'loaded';  //all children are loaded to be retained for missing ideal tiles\n+                sourceCache._tiles[idealID.key] = tile;\n+            }\n+\n+            // create retainment dictionary to pass by reference to _retainLoadedChildren for modification\n+            const retain: {[key: string]: OverscaledTileID} = {};\n+\n+            // create missing dictionary for ideal tiles for passing into _retainLoadedChildren\n+            const missingTiles: {[key: string]: OverscaledTileID} = {};\n+\n+            // mark all ideal tiles as retained and also as missing with no data for child retainment\n+            idealTileIDs.forEach(idealID => {\n+                retain[idealID.key] = idealID;\n+                missingTiles[idealID.key] = idealID;\n+            });\n+\n+            // retain loaded children for the missing ideal tiles\n+            sourceCache._retainLoadedChildren(missingTiles, retain);\n+\n+            expect(Object.keys(retain).sort()).toEqual(", "created_at": "2025-09-17T19:47:51+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347299952, "commenter_login": "HarelM", "comment_body": "Don't forget to revert this :-)", "file_path": "package.json", "diff_hunk": "@@ -24,7 +24,7 @@\n     \"@mapbox/unitbezier\": \"^0.0.1\",\n     \"@mapbox/vector-tile\": \"^2.0.4\",\n     \"@mapbox/whoots-js\": \"^3.1.0\",\n-    \"@maplibre/maplibre-gl-style-spec\": \"^23.3.0\",\n+    \"@maplibre/maplibre-gl-style-spec\": \"melitele/maplibre-style-spec.git#global-state-property-dist\",", "created_at": "2025-09-14T12:28:51+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347300257, "commenter_login": "HarelM", "comment_body": "Why was this added? Is there a way to avoid this \"as any\"?", "file_path": "test/bench/benchmarks/filter_evaluate.ts", "diff_hunk": "@@ -27,7 +27,7 @@ export default class FilterEvaluate extends Benchmark {\n             const layerFilters = [];\n             for (const filter of filters) {\n                 if (filter.layer === name) {\n-                    layerFilters.push(createFilter(filter.filter));\n+                    layerFilters.push(createFilter(filter.filter as any));", "created_at": "2025-09-14T12:29:45+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347300325, "commenter_login": "HarelM", "comment_body": "Same here", "file_path": "test/bench/benchmarks/filter_create.ts", "diff_hunk": "@@ -6,7 +6,7 @@ import filters from '../data/filters.json' with {type: 'json'};\n export default class FilterCreate extends Benchmark {\n     bench() {\n         for (const filter of filters) {\n-            createFilter(filter.filter);\n+            createFilter(filter.filter as any);", "created_at": "2025-09-14T12:29:55+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347301794, "commenter_login": "HarelM", "comment_body": "Just to make sure - when global state changes these places in the code where global state was passed get update, right?", "file_path": "src/style/style_layer.ts", "diff_hunk": "@@ -155,7 +156,7 @@ export abstract class StyleLayer extends Evented {\n \n     setFilter(filter: FilterSpecification | void) {\n         this.filter = filter;\n-        this._featureFilter = featureFilter(filter);\n+        this._featureFilter = featureFilter(filter, this._globalState);", "created_at": "2025-09-14T12:32:10+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347302540, "commenter_login": "HarelM", "comment_body": "Why was this moved out of the class?", "file_path": "src/style/evaluation_parameters.ts", "diff_hunk": "@@ -62,3 +57,7 @@ export class EvaluationParameters {\n             {fromScale: 0.5, toScale: 1, t: 1 - (1 - t) * fraction};\n     }\n }\n+\n+function isSupportedScript(str: string): boolean {", "created_at": "2025-09-14T12:34:07+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347303091, "commenter_login": "HarelM", "comment_body": "This is not part of the public API, right? If I understand correctly, this is needed in order to pass global state into the method, right? ", "file_path": "src/source/query_features.ts", "diff_hunk": "@@ -40,6 +40,7 @@ export type QueryRenderedFeaturesOptions = {\n \n export type QueryRenderedFeaturesOptionsStrict = Omit<QueryRenderedFeaturesOptions, 'layers'> & {\n     layers: Set<string> | null;\n+    globalState?: Record<string, any>;", "created_at": "2025-09-14T12:35:45+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347304300, "commenter_login": "HarelM", "comment_body": "Why not pass an empty object by default here and reduce some of the complexity of this line?\nMaybe `globalState` can be mandatory in `QueryRenderedFeaturesOptionsStrict`?", "file_path": "src/source/query_features.ts", "diff_hunk": "@@ -199,20 +203,21 @@ export function queryRenderedSymbols(styleLayers: {[_: string]: StyleLayer},\n     return convertFeaturesToMapFeaturesMultiple(result, styleLayers, sourceCaches);\n }\n \n-export function querySourceFeatures(sourceCache: SourceCache, params: QuerySourceFeatureOptions | undefined): GeoJSONFeature[] {\n+export function querySourceFeatures(sourceCache: SourceCache, params: QuerySourceFeatureOptions | undefined, globalState?: Record<string, any>): GeoJSONFeature[] {\n     const tiles = sourceCache.getRenderableIds().map((id) => {\n         return sourceCache.getTileByID(id);\n     });\n \n     const result: GeoJSONFeature[] = [];\n \n+    const qsfParams = globalState ? (params ? {...params, globalState} : {globalState}) : params;", "created_at": "2025-09-14T12:37:46+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347304985, "commenter_login": "HarelM", "comment_body": "This comment probably indicates that this needs to be a separate test, shouldn't it?", "file_path": "src/source/tile.test.ts", "diff_hunk": "@@ -47,9 +47,17 @@ describe('querySourceFeatures', () => {\n         tile.querySourceFeatures(result, {sourceLayer: undefined, filter: ['!=', 'oneway', true]});\n         expect(result).toHaveLength(0);\n         result = [];\n-        const polygon = {type: 'Polygon',  coordinates: [[[-91, -1], [-89, -1], [-89, 1], [-91, 1], [-91, -1]]]};\n+        const polygon = {type: 'Polygon',  coordinates: [[[-91, -1], [-89, -1], [-89, 1], [-91, 1], [-91, -1]]]} as GeoJSON.GeoJSON;\n         tile.querySourceFeatures(result, {sourceLayer: undefined, filter: ['within', polygon]});\n         expect(result).toHaveLength(1);\n+\n+        // filter with global-state", "created_at": "2025-09-14T12:38:42+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347809570, "commenter_login": "melitele", "comment_body": "it does now :-) see this [jsbin](https://jsbin.com/divagan/edit?html,js,output)\r\ngood catch, forgot to update `globalState` in `worker`", "file_path": "src/style/style_layer.ts", "diff_hunk": "@@ -155,7 +156,7 @@ export abstract class StyleLayer extends Evented {\n \n     setFilter(filter: FilterSpecification | void) {\n         this.filter = filter;\n-        this._featureFilter = featureFilter(filter);\n+        this._featureFilter = featureFilter(filter, this._globalState);", "created_at": "2025-09-15T03:36:36+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347937631, "commenter_login": "melitele", "comment_body": "TLDR: because [`spread operator (...)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) only works on own enumerable properties\r\n\r\nMy read on the definition of the [`GlobalProperties`](https://github.com/maplibre/maplibre-style-spec/blob/458cff9ead2e9f030c77068b1fb81de5bde32784/src/expression/index.ts#L59) is a simple, read only object. Hence my assumption that I can use operations that work on own enumerable properties (`spread operator (...)`, `Object.keys()` etc). And since it's read only, it has to be [copied prior to modification](https://github.com/maplibre/maplibre-style-spec/blob/458cff9ead2e9f030c77068b1fb81de5bde32784/src/expression/index.ts#L117) and spread operator is what is usually used.\r\n\r\n`EvaluationParameters` is passed as `GlobalProperties` - this change makes the relevant fields into own enumerable properties. The `isSupportedScript` implementation has no use of `this` so I moved it out.\r\n\r\nThe alternative to this change is to modify `maplibre-style-spec` so it doesn't assume the fields defined by `GlobalProperties` are own and enumerable.", "file_path": "src/style/evaluation_parameters.ts", "diff_hunk": "@@ -62,3 +57,7 @@ export class EvaluationParameters {\n             {fromScale: 0.5, toScale: 1, t: 1 - (1 - t) * fraction};\n     }\n }\n+\n+function isSupportedScript(str: string): boolean {", "created_at": "2025-09-15T05:51:13+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347955277, "commenter_login": "HarelM", "comment_body": "Does moving the method out what allowed the render test to pass?\r\nI not sure I'm following the value of moving the method out of the class, can you elaborate on that?", "file_path": "src/style/evaluation_parameters.ts", "diff_hunk": "@@ -62,3 +57,7 @@ export class EvaluationParameters {\n             {fromScale: 0.5, toScale: 1, t: 1 - (1 - t) * fraction};\n     }\n }\n+\n+function isSupportedScript(str: string): boolean {", "created_at": "2025-09-15T06:04:51+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2347983191, "commenter_login": "melitele", "comment_body": "Adding `isSupportedScript` as a property:\r\n```\r\nisSupportedScript: (_: string) => boolean = isSupportedScript;\r\n```\r\nallowed the render test to pass because the property became own and enumerable, i.e. visible to spread operator that I used to make a copy of the object passed as a parameter to 'evaluate` [here](https://github.com/maplibre/maplibre-style-spec/blob/458cff9ead2e9f030c77068b1fb81de5bde32784/src/expression/index.ts#L117).\r\n\r\nMoving the method out of the class dealt with the duplicate identifier problem that arisen when I added the property.\r\n", "file_path": "src/style/evaluation_parameters.ts", "diff_hunk": "@@ -62,3 +57,7 @@ export class EvaluationParameters {\n             {fromScale: 0.5, toScale: 1, t: 1 - (1 - t) * fraction};\n     }\n }\n+\n+function isSupportedScript(str: string): boolean {", "created_at": "2025-09-15T06:22:24+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2348000565, "commenter_login": "melitele", "comment_body": "`QueryRenderedFeaturesOptions` is public, `QueryRenderedFeaturesOptionsStrict` is not. The latter is the definition of parameters passed to the internal functions [`queryRenderedFeatures`](https://github.com/maplibre/maplibre-gl-js/blob/c4347b81a6f3a742118035cd30e91ebc767e3f67/src/source/query_features.ts#L104) & [`queryRenderedSymbols`](https://github.com/maplibre/maplibre-gl-js/blob/c4347b81a6f3a742118035cd30e91ebc767e3f67/src/source/query_features.ts#L144) that now need `globalState` because they indirectly instantiate filters (specifically call functions that do).", "file_path": "src/source/query_features.ts", "diff_hunk": "@@ -40,6 +40,7 @@ export type QueryRenderedFeaturesOptions = {\n \n export type QueryRenderedFeaturesOptionsStrict = Omit<QueryRenderedFeaturesOptions, 'layers'> & {\n     layers: Set<string> | null;\n+    globalState?: Record<string, any>;", "created_at": "2025-09-15T06:32:56+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2348001762, "commenter_login": "HarelM", "comment_body": "This seems a bit weird to me. While all other properties are data, and this object is DTO (Data transfer object), this property kind of break it.\nIt is possible to remove this property and calculate this part when it's needed?\nWhat is the trade of if we remove `isSupportedScript` from `GlobalProperties`? Or it's not possible because the evaluation logic is in style-spec and the RTL and other stuff is here?", "file_path": "src/style/evaluation_parameters.ts", "diff_hunk": "@@ -62,3 +57,7 @@ export class EvaluationParameters {\n             {fromScale: 0.5, toScale: 1, t: 1 - (1 - t) * fraction};\n     }\n }\n+\n+function isSupportedScript(str: string): boolean {", "created_at": "2025-09-15T06:33:43+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2348006605, "commenter_login": "melitele", "comment_body": "This is `params: QuerySourceFeatureOptions | undefined`, `QuerySourceFeatureOptions` being public. I'll see what I can do, I don't like this line either.", "file_path": "src/source/query_features.ts", "diff_hunk": "@@ -199,20 +203,21 @@ export function queryRenderedSymbols(styleLayers: {[_: string]: StyleLayer},\n     return convertFeaturesToMapFeaturesMultiple(result, styleLayers, sourceCaches);\n }\n \n-export function querySourceFeatures(sourceCache: SourceCache, params: QuerySourceFeatureOptions | undefined): GeoJSONFeature[] {\n+export function querySourceFeatures(sourceCache: SourceCache, params: QuerySourceFeatureOptions | undefined, globalState?: Record<string, any>): GeoJSONFeature[] {\n     const tiles = sourceCache.getRenderableIds().map((id) => {\n         return sourceCache.getTileByID(id);\n     });\n \n     const result: GeoJSONFeature[] = [];\n \n+    const qsfParams = globalState ? (params ? {...params, globalState} : {globalState}) : params;", "created_at": "2025-09-15T06:36:52+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2348048516, "commenter_login": "melitele", "comment_body": "It's possible to move some or all of the [script detection](https://github.com/maplibre/maplibre-gl-js/blob/main/src/util/script_detection.ts) code to `maplibe-style-spec`. It may even be a better _home_ for it. Then the only parameter that needs to be passed is a boolean that the RTL plugin is loaded.\r\n\r\nBeyond the scope of this PR.", "file_path": "src/style/evaluation_parameters.ts", "diff_hunk": "@@ -62,3 +57,7 @@ export class EvaluationParameters {\n             {fromScale: 0.5, toScale: 1, t: 1 - (1 - t) * fraction};\n     }\n }\n+\n+function isSupportedScript(str: string): boolean {", "created_at": "2025-09-15T07:00:07+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2348070548, "commenter_login": "HarelM", "comment_body": "Definitely beyond the score of this PR.\r\nI was thinking of moving the evaluation logic into this library and keeping only the valuation logic there. \r\nBut it's a big task either way.", "file_path": "src/style/evaluation_parameters.ts", "diff_hunk": "@@ -62,3 +57,7 @@ export class EvaluationParameters {\n             {fromScale: 0.5, toScale: 1, t: 1 - (1 - t) * fraction};\n     }\n }\n+\n+function isSupportedScript(str: string): boolean {", "created_at": "2025-09-15T07:12:12+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2348431478, "commenter_login": "HarelM", "comment_body": "What about deleting \"removed\" keys from global state?", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-15T09:41:51+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2348436999, "commenter_login": "HarelM", "comment_body": "Is there a better way to test this without using `ts-ignore`?", "file_path": "src/source/worker.test.ts", "diff_hunk": "@@ -140,4 +140,13 @@ describe('Worker generic testing', () => {\n         worker.actor.messageHandlers[MessageType.removeMap]('0', undefined);\n         expect(worker.layerIndexes['0']).toBeUndefined();\n     });\n+\n+    test('propagates global state', () => {\n+        const globalState = {key: 'value'};\n+        worker.actor.messageHandlers[MessageType.updateGlobalState]('0', globalState);\n+        //@ts-ignore", "created_at": "2025-09-15T09:43:46+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2350368903, "commenter_login": "melitele", "comment_body": "`globalState` in worker is an exact copy of the `globalState` in main thread. There is no deleting \"removed\" keys there.", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-16T00:14:22+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2350652708, "commenter_login": "HarelM", "comment_body": "This for look like like it a \"sync\" between the worker and the main thread, but it only adds keys and not removing keys, or am I misreading this?", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-16T03:53:01+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2350706825, "commenter_login": "melitele", "comment_body": "this is what [Style.setGlobalStateProperty](https://github.com/maplibre/maplibre-gl-js/blob/c437b82ea8a4f93b5cb9c3fce4f486ddb717951f/src/style/style.ts#L308) does:\r\n```\r\nconst newValue = value === null ? this.stylesheet.state?.[name]?.default ?? null : value;\r\nthis._globalState[name] = newValue; \r\n```\r\nand this is what [Style.setGlobalState](https://github.com/maplibre/maplibre-gl-js/blob/c437b82ea8a4f93b5cb9c3fce4f486ddb717951f/src/style/style.ts#L328) does:\r\n```\r\nfor (const propertyName in newStylesheetState) {\r\n    this._globalState[propertyName] = newStylesheetState[propertyName].default;\r\n}\r\n```", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-16T04:17:07+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2350722240, "commenter_login": "HarelM", "comment_body": "If params (main thread global state) has prop1 and prop2 but global state used to have prop3 on the worker, where is prop3 removed?", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-16T04:24:56+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2350736989, "commenter_login": "melitele", "comment_body": "How do you remove `prop3` from `global-state` on the main thread? ", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-16T04:32:27+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2350766547, "commenter_login": "HarelM", "comment_body": "I set a new global state that doesn't have prop3...?", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-16T04:48:12+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2350808435, "commenter_login": "melitele", "comment_body": "won't work, the [Style.setGlobalState](https://github.com/maplibre/maplibre-gl-js/blob/c437b82ea8a4f93b5cb9c3fce4f486ddb717951f/src/style/style.ts#L328) iterates over properties of the new object, so the `prop3` stays:\r\n```\r\nfor (const propertyName in newStylesheetState) {\r\n    this._globalState[propertyName] = newStylesheetState[propertyName].default;\r\n}\r\n```", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-16T05:08:40+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2350853080, "commenter_login": "HarelM", "comment_body": "Is this the intended behavior? Seems a bit strange to me that I can't delete properties from global state, although probably not a very common use case, but still...", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-16T05:25:14+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2350874056, "commenter_login": "melitele", "comment_body": "This is how it was originally implemented #5613\r\nWe can discuss it. Preferably outside this PR.", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-16T05:32:56+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6366, "comment_id": 2350891894, "commenter_login": "HarelM", "comment_body": "Fair enough, I can respect that.", "file_path": "src/source/worker.ts", "diff_hunk": "@@ -170,14 +173,30 @@ export default class Worker {\n         });\n \n         this.actor.registerMessageHandler(MessageType.updateLayers, async (mapId: string, params: UpdateLayersParameters) => {\n-            this._getLayerIndex(mapId).update(params.layers, params.removedIds);\n+            this._getLayerIndex(mapId).update(params.layers, params.removedIds, this._getGlobalState(mapId));\n+        });\n+\n+        this.actor.registerMessageHandler(MessageType.updateGlobalState, async (mapId: string, params: Record<string, any>) => {\n+            const globalState = this._getGlobalState(mapId);\n+            for (const key in params) {\n+                globalState[key] = params[key];", "created_at": "2025-09-16T05:39:21+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 3979, "comment_id": 1561450196, "commenter_login": "HarelM", "comment_body": "Since you moved the coords \"for\" into renderHillshade I would advise to move this as well into the prepareHillshade method, this way the methods are a bit more similar.", "file_path": "src/render/draw_hillshade.ts", "diff_hunk": "@@ -18,49 +18,72 @@ export function drawHillshade(painter: Painter, sourceCache: SourceCache, layer:\n     if (painter.renderPass !== 'offscreen' && painter.renderPass !== 'translucent') return;\n \n     const context = painter.context;\n+    const projection = painter.style.map.projection;\n+    const useSubdivision = projection.useSubdivision;\n \n     const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n     const colorMode = painter.colorModeForRenderPass();\n \n-    const [stencilModes, coords] = painter.renderPass === 'translucent' ?\n-        painter.stencilConfigForOverlap(tileIDs) : [{}, tileIDs];\n-\n-    for (const coord of coords) {\n-        const tile = sourceCache.getTile(coord);\n-        if (typeof tile.needsHillshadePrepare !== 'undefined' && tile.needsHillshadePrepare && painter.renderPass === 'offscreen') {\n-            prepareHillshade(painter, tile, layer, depthMode, StencilMode.disabled, colorMode);\n-        } else if (painter.renderPass === 'translucent') {\n-            renderHillshade(painter, coord, tile, layer, depthMode, stencilModes[coord.overscaledZ], colorMode);\n+    if (painter.renderPass === 'offscreen') {\n+        // Prepare tiles\n+        for (const coord of tileIDs) {", "created_at": "2024-04-11T18:17:27+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 3979, "comment_id": 1562389280, "commenter_login": "kubapelc", "comment_body": "Done!", "file_path": "src/render/draw_hillshade.ts", "diff_hunk": "@@ -18,49 +18,72 @@ export function drawHillshade(painter: Painter, sourceCache: SourceCache, layer:\n     if (painter.renderPass !== 'offscreen' && painter.renderPass !== 'translucent') return;\n \n     const context = painter.context;\n+    const projection = painter.style.map.projection;\n+    const useSubdivision = projection.useSubdivision;\n \n     const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n     const colorMode = painter.colorModeForRenderPass();\n \n-    const [stencilModes, coords] = painter.renderPass === 'translucent' ?\n-        painter.stencilConfigForOverlap(tileIDs) : [{}, tileIDs];\n-\n-    for (const coord of coords) {\n-        const tile = sourceCache.getTile(coord);\n-        if (typeof tile.needsHillshadePrepare !== 'undefined' && tile.needsHillshadePrepare && painter.renderPass === 'offscreen') {\n-            prepareHillshade(painter, tile, layer, depthMode, StencilMode.disabled, colorMode);\n-        } else if (painter.renderPass === 'translucent') {\n-            renderHillshade(painter, coord, tile, layer, depthMode, stencilModes[coord.overscaledZ], colorMode);\n+    if (painter.renderPass === 'offscreen') {\n+        // Prepare tiles\n+        for (const coord of tileIDs) {", "created_at": "2024-04-12T10:53:06+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6381, "comment_id": 2335601635, "commenter_login": "HarelM", "comment_body": "Consider passing both options instead of this string.", "file_path": "src/style/query_utils.ts", "diff_hunk": "@@ -78,3 +81,71 @@ export function offsetLine(rings: Array<Array<Point>>, offset: number) {\n     }\n     return newRings;\n }\n+\n+type CircleIntersectionTestParams = {\n+    queryGeometry: Array<Point>;\n+    point: Point;\n+    size: number;\n+    transform: IReadonlyTransform;\n+    unwrappedTileID: UnwrappedTileID;\n+    getElevation: undefined | ((x: number, y: number) => number);\n+    intersectionTest?: 'map-map' | 'map-viewport' | 'viewport-map' | 'viewport-viewport';", "created_at": "2025-09-10T05:31:53+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6381, "comment_id": 2347311469, "commenter_login": "HarelM", "comment_body": "I find this map a bit odd. This is static right? Why not use switch case or if-else?", "file_path": "src/style/query_utils.ts", "diff_hunk": "@@ -78,3 +81,93 @@ export function offsetLine(rings: Array<Array<Point>>, offset: number) {\n     }\n     return newRings;\n }\n+\n+type CircleIntersectionTestParams = {\n+    queryGeometry: Array<Point>;\n+    point: Point;\n+    size: number;\n+    transform: IReadonlyTransform;\n+    unwrappedTileID: UnwrappedTileID;\n+    getElevation: undefined | ((x: number, y: number) => number);\n+    pitchAlignment?: 'map' | 'viewport';\n+    pitchScale?: 'map' | 'viewport';\n+};\n+\n+const circleIntersectionTests = new Map<string, Map<string, (params: CircleIntersectionTestParams) => boolean>>([", "created_at": "2025-09-14T12:52:01+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6381, "comment_id": 2347312062, "commenter_login": "HarelM", "comment_body": "Nice work with the tests here!", "file_path": "src/style/style_layer/heatmap_style_layer.test.ts", "diff_hunk": "", "created_at": "2025-09-14T12:53:38+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6381, "comment_id": 2347312751, "commenter_login": "HarelM", "comment_body": "Consider adding types to these variables since they are only initialized later on and adding a type will guard wrong initialization value I believe.", "file_path": "src/style/style_layer/circle_style_layer.ts", "diff_hunk": "@@ -62,45 +58,30 @@ export class CircleStyleLayer extends StyleLayer {\n         // Otherwise, compare geometry in the plane of the viewport\n         // A circle with fixed scaling relative to the viewport gets larger in tile space as it moves into the distance\n         // A circle with fixed scaling relative to the map gets smaller in viewport space as it moves into the distance\n-        const alignWithMap = this.paint.get('circle-pitch-alignment') === 'map';\n-        const transformedPolygon = alignWithMap ? translatedPolygon : projectQueryGeometry(translatedPolygon, transform, unwrappedTileID, getElevation);\n-        const transformedSize = alignWithMap ? size * pixelsToTileUnits : size;\n \n-        for (const ring of geometry) {\n-            for (const point of ring) {\n-\n-                const transformedPoint = alignWithMap ? point : projectPoint(point, transform, unwrappedTileID, getElevation);\n-\n-                let adjustedSize = transformedSize;\n-                const w = transform.projectTileCoordinates(point.x, point.y, unwrappedTileID, getElevation).signedDistanceFromCamera;\n-\n-                if (this.paint.get('circle-pitch-scale') === 'viewport' && this.paint.get('circle-pitch-alignment') === 'map') {\n-                    adjustedSize *= w / transform.cameraToCenterDistance;\n-                } else if (this.paint.get('circle-pitch-scale') === 'map' && this.paint.get('circle-pitch-alignment') === 'viewport') {\n-                    adjustedSize *= transform.cameraToCenterDistance / w;\n-                }\n-\n-                if (polygonIntersectsBufferedPoint(transformedPolygon, transformedPoint, adjustedSize)) return true;\n-            }\n+        const pitchScale = this.paint.get('circle-pitch-scale');\n+        const pitchAlignment = this.paint.get('circle-pitch-alignment');\n+\n+        let transformedPolygon;", "created_at": "2025-09-14T12:55:11+00:00"}
{"repo": "maplibre/maplibre-gl-js", "pr_number": 6381, "comment_id": 2347316177, "commenter_login": "HarelM", "comment_body": "These tests are great and were probably needed in the past as well. Can you check that they pass before your refactoring of circle layer? It would be a good indication that nothing got broken.\nI know I played with this code a bit and it felt a bit shaky...\n", "file_path": "src/style/style_layer/circle_style_layer.test.ts", "diff_hunk": "", "created_at": "2025-09-14T12:58:54+00:00"}
